# Claude Relay Service - 数据存储架构调整方案

## 📋 问题分析

### 当前架构问题

目前项目完全依赖 Redis 存储所有数据，存在以下问题：

1. **内存成本过高**
   - Redis 是内存数据库，1GB 内存成本远高于 1GB 磁盘
   - 随着用户增长，内存开销呈线性增长
   - 例：10万用户数据 + 订单历史，可能需要 10GB+ 内存

2. **数据持久化风险**
   - Redis 主要用于缓存，虽然支持 RDB/AOF 持久化，但不如关系型数据库可靠
   - 一旦 Redis 故障，可能丢失业务数据
   - 恢复困难，备份机制不完善

3. **查询能力受限**
   - 不支持复杂的关联查询
   - 统计分析困难（如：按月统计收入、用户增长趋势）
   - 无法使用 SQL 进行灵活的数据分析

4. **扩展性问题**
   - Redis 单机内存有限（通常 64GB-256GB）
   - 虽然可以使用 Redis Cluster，但增加复杂度和成本
   - 不如关系型数据库的垂直/水平扩展成熟

---

## 🎯 推荐架构方案

### 核心思想：PostgreSQL + Redis 混合架构

- **PostgreSQL**：存储所有业务数据（持久化、主要数据）
- **Redis**：缓存、会话、限流、临时数据（高性能、短期数据）

### 为什么选择 PostgreSQL？

1. **功能强大**
   - 完整的 ACID 事务支持
   - 丰富的数据类型（JSON、数组、时间等）
   - 强大的索引能力（B-tree、Hash、GiST、GIN）
   - 支持全文搜索

2. **开源免费**
   - MIT-like 开源协议
   - 无需付费许可
   - 社区活跃

3. **性能优秀**
   - 支持百万级数据查询
   - 优秀的并发处理能力
   - 成熟的查询优化器

4. **JSON 支持**
   - 原生支持 JSON/JSONB 类型
   - 可以灵活存储半结构化数据
   - 兼具关系型和文档型数据库的优点

5. **成熟稳定**
   - 30+ 年历史
   - 大量生产环境验证
   - 丰富的运维工具

### 其他选择

- **MySQL**：也是不错的选择，生态更大，但 JSON 支持不如 PostgreSQL
- **SQLite**：适合小型项目，但不适合多用户并发场景
- **MongoDB**：文档型数据库，但关系查询不如 PostgreSQL，且需要额外学习

---

## 📊 数据分层策略

### 第一层：PostgreSQL（持久化存储）

存储所有业务数据，作为数据的唯一可信来源（Single Source of Truth）。

```
PostgreSQL 存储的数据类型：
- 用户账户数据（users）
- 订阅信息（subscriptions）
- 套餐配置（plans）
- 订单记录（orders）
- 支付记录（payments）
- API Keys（api_keys）
- 优惠券（coupons）
- 邀请关系（referrals）
- 工单系统（tickets）
- 通知记录（notifications）
- 使用历史（usage_history）
```

### 第二层：Redis（缓存与临时数据）

缓存热点数据，存储临时数据，提升性能。

```
Redis 存储的数据类型：
- 会话数据（session）
- Token 黑名单（token_blacklist）
- 限流计数（rate_limit）
- 当前额度（quota_current）
- 热点数据缓存（cache）
- 队列任务（queue）
- 实时统计（stats_realtime）
- 验证码（verification_code）
```

### 数据流转示例

```
读取流程：
1. 查询 Redis 缓存
2. 缓存命中 → 直接返回
3. 缓存未命中 → 查询 PostgreSQL
4. 将结果写入 Redis 缓存（设置过期时间）
5. 返回结果

写入流程：
1. 写入 PostgreSQL（持久化）
2. 成功后更新 Redis 缓存
3. 失败时回滚事务
```

---

## 🗄️ PostgreSQL 数据库设计

### 核心表结构

#### 1. 用户表（users）

```sql
CREATE TABLE users (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    email VARCHAR(255) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    email_verified BOOLEAN DEFAULT FALSE,
    status VARCHAR(20) DEFAULT 'active', -- active | suspended | deleted
    role VARCHAR(20) DEFAULT 'user', -- user | admin
    
    -- 邀请信息
    referral_code VARCHAR(50) UNIQUE,
    invited_by UUID REFERENCES users(id),
    
    -- 时间戳
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    last_login_at TIMESTAMP,
    
    -- 索引
    INDEX idx_email (email),
    INDEX idx_referral_code (referral_code),
    INDEX idx_created_at (created_at)
);
```

#### 2. 套餐表（plans）

```sql
CREATE TABLE plans (
    id VARCHAR(50) PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    description TEXT,
    type VARCHAR(20) NOT NULL, -- subscription | one-time
    
    -- 价格信息
    price DECIMAL(10, 2) NOT NULL,
    currency VARCHAR(3) DEFAULT 'CNY',
    billing_cycle VARCHAR(20), -- monthly | yearly | lifetime
    
    -- 功能配置（JSON）
    features JSONB NOT NULL,
    
    -- 额外配置
    trial_days INTEGER DEFAULT 0,
    discount JSONB,
    
    -- 状态和排序
    status VARCHAR(20) DEFAULT 'active', -- active | inactive | archived
    sort_order INTEGER DEFAULT 0,
    is_popular BOOLEAN DEFAULT FALSE,
    is_recommended BOOLEAN DEFAULT FALSE,
    
    -- 时间戳
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    -- 索引
    INDEX idx_status (status),
    INDEX idx_sort_order (sort_order)
);
```

#### 3. 订阅表（subscriptions）

```sql
CREATE TABLE subscriptions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id),
    plan_id VARCHAR(50) NOT NULL REFERENCES plans(id),
    
    -- 套餐快照（防止套餐变更影响已有订阅）
    plan_snapshot JSONB NOT NULL,
    
    -- 状态
    status VARCHAR(20) DEFAULT 'active', -- active | expired | cancelled | suspended
    
    -- 时间信息
    start_date DATE NOT NULL,
    expire_date DATE NOT NULL,
    next_billing_date DATE,
    cancelled_at TIMESTAMP,
    
    -- 自动续费
    auto_renew BOOLEAN DEFAULT TRUE,
    auto_renew_failed_count INTEGER DEFAULT 0,
    
    -- 时间戳
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    -- 索引
    INDEX idx_user_id (user_id),
    INDEX idx_status (status),
    INDEX idx_expire_date (expire_date),
    
    -- 约束：一个用户同时只能有一个有效订阅
    UNIQUE INDEX idx_user_active (user_id) WHERE status = 'active'
);
```

#### 4. 订单表（orders）

```sql
CREATE TABLE orders (
    id VARCHAR(50) PRIMARY KEY,
    user_id UUID NOT NULL REFERENCES users(id),
    plan_id VARCHAR(50) NOT NULL REFERENCES plans(id),
    
    -- 金额信息
    original_price DECIMAL(10, 2) NOT NULL,
    discount_amount DECIMAL(10, 2) DEFAULT 0,
    final_price DECIMAL(10, 2) NOT NULL,
    currency VARCHAR(3) DEFAULT 'CNY',
    
    -- 优惠信息
    coupon_code VARCHAR(50),
    invite_discount DECIMAL(10, 2) DEFAULT 0,
    
    -- 订单状态
    status VARCHAR(20) DEFAULT 'pending', -- pending | paid | cancelled | expired | refunded
    payment_method VARCHAR(20), -- alipay | wechat | stripe
    payment_status VARCHAR(20) DEFAULT 'pending', -- pending | success | failed
    
    -- 支付信息（JSON）
    payment_info JSONB,
    
    -- 时间信息
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    paid_at TIMESTAMP,
    cancelled_at TIMESTAMP,
    expire_at TIMESTAMP, -- 订单过期时间（15分钟）
    
    -- 索引
    INDEX idx_user_id (user_id),
    INDEX idx_status (status),
    INDEX idx_created_at (created_at),
    INDEX idx_expire_at (expire_at)
);
```

[其他表结构省略，详见完整设计文档]

---

## 🔄 Redis 缓存策略

### 缓存的数据类型

```javascript
// 1. 会话数据（30分钟过期）
session:{sessionId} = {
  userId: "xxx",
  email: "xxx",
  role: "user"
}

// 2. Token黑名单（按token过期时间设置TTL）
blacklist_token:{token} = true

// 3. 限流计数（1分钟过期）
rate_limit:{userId}:{endpoint} = count

// 4. 当前额度（24小时过期，每次请求后更新）
quota_current:{userId} = {
  requests_used: 45,
  tokens_used: 350000,
  reset_at: "timestamp"
}

// 5. 热点数据缓存（10分钟过期）
cache:user:{userId} = { /* 用户信息 */ }
cache:subscription:{userId} = { /* 订阅信息 */ }
cache:plan:{planId} = { /* 套餐信息 */ }

// 6. 验证码（15分钟过期）
verification_code:{email} = "123456"

// 7. 密码重置Token（1小时过期）
password_reset_token:{token} = userId

// 8. 邮箱验证Token（24小时过期）
email_verify_token:{token} = { userId, email }

// 9. 实时统计（1分钟过期）
stats:realtime:active_users = 320
stats:realtime:requests_per_minute = 1250
```

### 缓存更新策略（Cache-Aside）

```javascript
// 读取数据
async function getUser(userId) {
  // 1. 尝试从缓存获取
  let user = await redis.get(`cache:user:${userId}`);
  
  if (user) {
    return JSON.parse(user);
  }
  
  // 2. 缓存未命中，从数据库读取
  user = await db.query('SELECT * FROM users WHERE id = $1', [userId]);
  
  if (user) {
    // 3. 写入缓存（10分钟过期）
    await redis.setex(`cache:user:${userId}`, 600, JSON.stringify(user));
  }
  
  return user;
}

// 更新数据
async function updateUser(userId, data) {
  // 1. 更新数据库
  await db.query('UPDATE users SET ... WHERE id = $1', [userId]);
  
  // 2. 删除缓存（让下次读取时重新加载）
  await redis.del(`cache:user:${userId}`);
  
  // 或者直接更新缓存
  // await redis.setex(`cache:user:${userId}`, 600, JSON.stringify(newData));
}
```

---

## 📝 对邮箱登录系统的影响

### 需要修改的部分

#### 1. 用户注册

**原设计（纯Redis）：**
```javascript
// 将用户信息存储到 Redis
await redis.hset(`user:${userId}`, userData);
await redis.set(`email_to_userid:${email}`, userId);
```

**新设计（PostgreSQL + Redis）：**
```javascript
// 1. 存储到 PostgreSQL
const user = await db.query(
  'INSERT INTO users (email, password_hash, referral_code) VALUES ($1, $2, $3) RETURNING *',
  [email, passwordHash, referralCode]
);

// 2. 生成验证Token（存储到Redis，24小时过期）
const verifyToken = generateToken();
await redis.setex(`email_verify_token:${verifyToken}`, 86400, JSON.stringify({
  userId: user.id,
  email: user.email
}));

// 3. 发送验证邮件
await sendVerificationEmail(email, verifyToken);
```

#### 2. 用户登录

**原设计（纯Redis）：**
```javascript
// 从 Redis 获取用户
const userId = await redis.get(`email_to_userid:${email}`);
const user = await redis.hgetall(`user:${userId}`);
```

**新设计（PostgreSQL + Redis）：**
```javascript
// 1. 从数据库查询用户
const user = await db.query(
  'SELECT * FROM users WHERE email = $1',
  [email]
);

// 2. 验证密码
const isValid = await bcrypt.compare(password, user.password_hash);

// 3. 生成Token并存储Session到Redis（30分钟）
const accessToken = generateAccessToken(user);
const sessionId = generateSessionId();
await redis.setex(`session:${sessionId}`, 1800, JSON.stringify({
  userId: user.id,
  email: user.email,
  role: user.role
}));

// 4. 更新最后登录时间（异步，不阻塞）
db.query('UPDATE users SET last_login_at = NOW() WHERE id = $1', [user.id]);
```

#### 3. Token验证中间件

**原设计（纯Redis）：**
```javascript
// 验证Token，从Redis获取用户信息
const user = await redis.hgetall(`user:${userId}`);
```

**新设计（PostgreSQL + Redis）：**
```javascript
// 1. 验证Token
const decoded = jwt.verify(token, JWT_SECRET);

// 2. 检查Token黑名单（Redis）
const isBlacklisted = await redis.get(`blacklist_token:${token}`);
if (isBlacklisted) throw new Error('Token已失效');

// 3. 从缓存获取用户信息
let user = await redis.get(`cache:user:${decoded.userId}`);

if (!user) {
  // 缓存未命中，从数据库查询
  user = await db.query('SELECT * FROM users WHERE id = $1', [decoded.userId]);
  
  // 写入缓存（10分钟）
  await redis.setex(`cache:user:${decoded.userId}`, 600, JSON.stringify(user));
}

req.user = user;
```

#### 4. 修改密码

**原设计（纯Redis）：**
```javascript
await redis.hset(`user:${userId}`, 'password_hash', newPasswordHash);
```

**新设计（PostgreSQL + Redis）：**
```javascript
// 1. 更新数据库
await db.query(
  'UPDATE users SET password_hash = $1, updated_at = NOW() WHERE id = $2',
  [newPasswordHash, userId]
);

// 2. 清除缓存
await redis.del(`cache:user:${userId}`);

// 3. 将所有旧Token加入黑名单（强制重新登录）
// 这需要记录用户的所有活动Token，或者使用Token版本号机制
```

### 不需要修改的部分

以下功能继续使用 Redis 即可，不需要存储到数据库：

- ✅ Token黑名单
- ✅ 登录失败限制
- ✅ 限流计数
- ✅ 验证码
- ✅ 密码重置Token（临时）
- ✅ 邮箱验证Token（临时）

---

## 🔄 数据迁移方案

### 如果已有Redis数据

```javascript
// 将现有Redis数据迁移到PostgreSQL

async function migrateFromRedisToPostgres() {
  // 1. 获取所有用户
  const userKeys = await redis.keys('user:*');
  
  for (const key of userKeys) {
    const userData = await redis.hgetall(key);
    
    // 2. 插入到PostgreSQL
    await db.query(
      `INSERT INTO users (id, email, password_hash, email_verified, created_at)
       VALUES ($1, $2, $3, $4, $5)
       ON CONFLICT (id) DO NOTHING`,
      [
        userData.id,
        userData.email,
        userData.password_hash,
        userData.email_verified === 'true',
        userData.created_at
      ]
    );
  }
  
  console.log('Migration completed');
}
```

---

## 📊 性能对比

### 内存使用对比

**纯 Redis 方案：**
- 10万用户基础数据：~500MB
- 100万订单记录：~5GB
- 使用历史数据：~10GB
- **总计：约 15GB+ 内存**

**PostgreSQL + Redis 方案：**
- PostgreSQL：15GB 磁盘（成本低）
- Redis（仅缓存和临时数据）：~500MB 内存
- **总计：500MB 内存 + 15GB 磁盘**

### 成本对比（阿里云为例）

**纯 Redis：**
- 16GB Redis 实例：约 ¥1000/月

**PostgreSQL + Redis：**
- 4GB PostgreSQL：约 ¥200/月
- 1GB Redis：约 ¥100/月
- **总计：约 ¥300/月**

**节省成本：70%**

---

## ✅ 实施步骤

### 第一阶段：数据库设置（1天）

1. 安装 PostgreSQL
2. 创建数据库和用户
3. 运行建表SQL脚本
4. 配置数据库连接

### 第二阶段：ORM集成（1-2天）

1. 安装 Prisma
2. 定义数据模型
3. 生成迁移文件
4. 测试数据库连接

### 第三阶段：代码调整（3-5天）

1. 修改用户认证模块
2. 实现缓存层
3. 修改现有API
4. 添加数据库查询优化

### 第四阶段：数据迁移（1天）

1. 编写迁移脚本
2. 测试迁移流程
3. 执行迁移
4. 验证数据完整性

### 第五阶段：测试和优化（2-3天）

1. 功能测试
2. 性能测试
3. 压力测试
4. 监控调优

**总计：约 1-2 周**

---

## 🛠️ 开发环境配置

### 1. 安装 PostgreSQL

**macOS：**
```bash
brew install postgresql@16
brew services start postgresql@16
```

**Ubuntu/Debian：**
```bash
sudo apt update
sudo apt install postgresql postgresql-contrib
sudo systemctl start postgresql
```

**Docker（推荐）：**
```bash
docker run -d \
  --name postgres \
  -e POSTGRES_PASSWORD=yourpassword \
  -e POSTGRES_DB=claude_relay \
  -p 5432:5432 \
  -v postgres_data:/var/lib/postgresql/data \
  postgres:16
```

### 2. 创建数据库

```bash
# 连接到 PostgreSQL
psql -U postgres

# 创建数据库
CREATE DATABASE claude_relay;

# 创建用户
CREATE USER crs_user WITH PASSWORD 'your_secure_password';

# 授权
GRANT ALL PRIVILEGES ON DATABASE claude_relay TO crs_user;
```

### 3. 环境变量配置

```bash
# .env 文件添加

# PostgreSQL 配置
DB_HOST=localhost
DB_PORT=5432
DB_NAME=claude_relay
DB_USER=crs_user
DB_PASSWORD=your_secure_password
DATABASE_URL=postgresql://crs_user:your_secure_password@localhost:5432/claude_relay

# Redis 配置（保持不变）
REDIS_HOST=localhost
REDIS_PORT=6379
REDIS_PASSWORD=
```

---

## 📈 监控建议

### 数据库监控

```javascript
// 监控数据库连接池
setInterval(() => {
  console.log('DB Pool Status:', {
    total: pool.totalCount,
    idle: pool.idleCount,
    waiting: pool.waitingCount
  });
}, 60000);

// 监控慢查询
// 在 PostgreSQL 中配置：
// log_min_duration_statement = 1000  # 记录超过1秒的查询
```

### 缓存监控

```javascript
// 监控缓存命中率
let cacheHits = 0;
let cacheMisses = 0;

setInterval(() => {
  const hitRate = (cacheHits / (cacheHits + cacheMisses) * 100).toFixed(2);
  console.log(`Cache Hit Rate: ${hitRate}%`);
  
  // 重置计数
  cacheHits = 0;
  cacheMisses = 0;
}, 60000);
```

---

## ⚠️ 注意事项

### 1. 数据一致性

- 先写数据库，再更新缓存
- 数据库写入失败时，不更新缓存
- 使用事务保证关键操作的原子性

### 2. 缓存失效

- 设置合理的缓存过期时间
- 数据更新时主动清除缓存
- 避免缓存雪崩（随机过期时间）

### 3. 备份策略

- 数据库每日自动备份
- 保留最近7天的备份
- 定期测试恢复流程

### 4. 索引优化

- 为常用查询字段添加索引
- 定期分析查询性能（EXPLAIN）
- 避免过多索引影响写入性能

---

## 📚 推荐阅读

- [PostgreSQL官方文档](https://www.postgresql.org/docs/)
- [Prisma文档](https://www.prisma.io/docs)
- [Redis缓存策略](https://redis.io/docs/manual/patterns/)
- [数据库设计最佳实践](https://www.postgresql.org/docs/current/tutorial.html)

---

**文档版本：** v1.0  
**最后更新：** 2024-12-26  
**作者：** Claude

# è®¢å•æ”¯ä»˜ç³»ç»Ÿè¯¦ç»†è®¾è®¡æ–‡æ¡£

## ğŸ“‹ åŠŸèƒ½æ¦‚è¿°

è®¢å•æ”¯ä»˜ç³»ç»Ÿæ˜¯å•†ä¸šåŒ–å¹³å°çš„æ ¸å¿ƒæ¨¡å—ï¼Œè´Ÿè´£å¤„ç†ç”¨æˆ·è´­ä¹°å¥—é¤çš„å®Œæ•´æµç¨‹ï¼ŒåŒ…æ‹¬è®¢å•åˆ›å»ºã€æ”¯ä»˜å¤„ç†ã€å›è°ƒéªŒè¯ã€è®¢å•çŠ¶æ€ç®¡ç†ç­‰ã€‚

### æ ¸å¿ƒåŠŸèƒ½

- âœ… è®¢å•åˆ›å»ºå’Œç®¡ç†
- âœ… å¤šç§æ”¯ä»˜æ–¹å¼é›†æˆï¼ˆæ”¯ä»˜å®ã€å¾®ä¿¡ã€Stripeï¼‰
- âœ… æ”¯ä»˜å›è°ƒå¤„ç†å’ŒéªŒè¯
- âœ… è®¢å•çŠ¶æ€è·Ÿè¸ª
- âœ… è®¢å•è‡ªåŠ¨è¿‡æœŸ
- âœ… é€€æ¬¾å¤„ç†
- âœ… è®¢å•æŸ¥è¯¢å’Œç»Ÿè®¡

### ä¸šåŠ¡åœºæ™¯

```
ç”¨æˆ·è´­ä¹°æµç¨‹ï¼š
1. ç”¨æˆ·é€‰æ‹©å¥—é¤
2. åˆ›å»ºè®¢å•ï¼ˆè®¡ç®—ä»·æ ¼ã€åº”ç”¨ä¼˜æƒ ï¼‰
3. é€‰æ‹©æ”¯ä»˜æ–¹å¼
4. è·³è½¬åˆ°æ”¯ä»˜é¡µé¢
5. å®Œæˆæ”¯ä»˜
6. æ”¯ä»˜å¹³å°å›è°ƒé€šçŸ¥
7. éªŒè¯æ”¯ä»˜ç»“æœ
8. å¼€é€šè®¢é˜…æœåŠ¡
9. å‘é€è´­ä¹°æˆåŠŸé€šçŸ¥

å¼‚å¸¸å¤„ç†ï¼š
- è®¢å•è¶…æ—¶æœªæ”¯ä»˜ â†’ è‡ªåŠ¨å–æ¶ˆ
- æ”¯ä»˜å¤±è´¥ â†’ å…è®¸é‡æ–°æ”¯ä»˜
- é‡å¤æ”¯ä»˜ â†’ é˜²é‡å¤å¤„ç†
- å›è°ƒç­¾åé”™è¯¯ â†’ æ‹’ç»è¯·æ±‚
```

---

## ğŸ—„ï¸ æ•°æ®åº“è®¾è®¡

### 1. è®¢å•è¡¨ï¼ˆordersï¼‰

```sql
CREATE TABLE orders (
    -- ä¸»é”®
    id VARCHAR(50) PRIMARY KEY,              -- è®¢å•å·ï¼Œå¦‚ï¼šORD20240126123456789
    
    -- å…³è”ä¿¡æ¯
    user_id UUID NOT NULL REFERENCES users(id),
    plan_id VARCHAR(50) NOT NULL REFERENCES plans(id),
    
    -- å¥—é¤å¿«ç…§ï¼ˆè®°å½•è´­ä¹°æ—¶çš„å¥—é¤ä¿¡æ¯ï¼Œé˜²æ­¢å¥—é¤å˜æ›´å½±å“è®¢å•ï¼‰
    plan_snapshot JSONB NOT NULL,
    
    -- é‡‘é¢ä¿¡æ¯ï¼ˆå•ä½ï¼šå…ƒï¼Œä¿ç•™2ä½å°æ•°ï¼‰
    original_price DECIMAL(10, 2) NOT NULL,    -- åŸä»·
    discount_amount DECIMAL(10, 2) DEFAULT 0,  -- ä¼˜æƒ é‡‘é¢
    final_price DECIMAL(10, 2) NOT NULL,       -- å®ä»˜é‡‘é¢
    currency VARCHAR(3) DEFAULT 'CNY',          -- è´§å¸ç±»å‹
    
    -- ä¼˜æƒ ä¿¡æ¯
    coupon_code VARCHAR(50),                    -- ä½¿ç”¨çš„ä¼˜æƒ åˆ¸
    coupon_discount DECIMAL(10, 2) DEFAULT 0,   -- ä¼˜æƒ åˆ¸å‡å…
    invite_discount DECIMAL(10, 2) DEFAULT 0,   -- é‚€è¯·ä¼˜æƒ å‡å…
    
    -- è®¢å•çŠ¶æ€
    status VARCHAR(20) DEFAULT 'pending',       -- pending | paid | cancelled | expired | refunded
    payment_method VARCHAR(20),                 -- alipay | wechat | stripe
    payment_status VARCHAR(20) DEFAULT 'pending', -- pending | success | failed | refunded
    
    -- æ”¯ä»˜ä¿¡æ¯
    payment_info JSONB,                         -- æ”¯ä»˜ç›¸å…³ä¿¡æ¯ï¼ˆäºŒç»´ç ã€é“¾æ¥ç­‰ï¼‰
    transaction_id VARCHAR(100),                -- ç¬¬ä¸‰æ–¹æ”¯ä»˜äº¤æ˜“å·
    
    -- IPå’Œè®¾å¤‡ä¿¡æ¯
    user_ip VARCHAR(50),                        -- ç”¨æˆ·IP
    user_agent TEXT,                            -- ç”¨æˆ·è®¾å¤‡ä¿¡æ¯
    
    -- å¤‡æ³¨
    note TEXT,                                  -- è®¢å•å¤‡æ³¨
    cancel_reason TEXT,                         -- å–æ¶ˆåŸå› 
    refund_reason TEXT,                         -- é€€æ¬¾åŸå› 
    
    -- æ—¶é—´ä¿¡æ¯
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    paid_at TIMESTAMP,                          -- æ”¯ä»˜å®Œæˆæ—¶é—´
    cancelled_at TIMESTAMP,                     -- å–æ¶ˆæ—¶é—´
    refunded_at TIMESTAMP,                      -- é€€æ¬¾æ—¶é—´
    expire_at TIMESTAMP,                        -- è®¢å•è¿‡æœŸæ—¶é—´ï¼ˆåˆ›å»ºå15åˆ†é’Ÿï¼‰
    
    -- ç´¢å¼•
    INDEX idx_user_id (user_id),
    INDEX idx_plan_id (plan_id),
    INDEX idx_status (status),
    INDEX idx_payment_status (payment_status),
    INDEX idx_created_at (created_at),
    INDEX idx_expire_at (expire_at),
    INDEX idx_transaction_id (transaction_id)
);

-- è‡ªåŠ¨æ›´æ–°è¿‡æœŸæ—¶é—´è§¦å‘å™¨
CREATE OR REPLACE FUNCTION set_order_expire_time()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.expire_at IS NULL THEN
        NEW.expire_at = NEW.created_at + INTERVAL '15 minutes';
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER set_order_expire_time_trigger
    BEFORE INSERT ON orders
    FOR EACH ROW
    EXECUTE FUNCTION set_order_expire_time();
```

### 2. æ”¯ä»˜å›è°ƒæ—¥å¿—è¡¨ï¼ˆpayment_callbacksï¼‰

```sql
CREATE TABLE payment_callbacks (
    id BIGSERIAL PRIMARY KEY,
    order_id VARCHAR(50) NOT NULL REFERENCES orders(id),
    
    -- å›è°ƒä¿¡æ¯
    payment_method VARCHAR(20) NOT NULL,        -- æ”¯ä»˜æ–¹å¼
    callback_data JSONB NOT NULL,               -- å®Œæ•´çš„å›è°ƒæ•°æ®
    
    -- éªŒè¯ä¿¡æ¯
    signature_valid BOOLEAN,                    -- ç­¾åæ˜¯å¦æœ‰æ•ˆ
    verification_result TEXT,                   -- éªŒè¯ç»“æœè¯´æ˜
    
    -- å¤„ç†ä¿¡æ¯
    processed BOOLEAN DEFAULT FALSE,            -- æ˜¯å¦å·²å¤„ç†
    process_result TEXT,                        -- å¤„ç†ç»“æœ
    error_message TEXT,                         -- é”™è¯¯ä¿¡æ¯ï¼ˆå¦‚æœæœ‰ï¼‰
    
    -- æ¥æºä¿¡æ¯
    source_ip VARCHAR(50),                      -- å›è°ƒæ¥æºIP
    
    -- æ—¶é—´æˆ³
    received_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    processed_at TIMESTAMP,
    
    -- ç´¢å¼•
    INDEX idx_order_id (order_id),
    INDEX idx_payment_method (payment_method),
    INDEX idx_processed (processed),
    INDEX idx_received_at (received_at)
);
```

### 3. é€€æ¬¾è®°å½•è¡¨ï¼ˆrefundsï¼‰

```sql
CREATE TABLE refunds (
    id VARCHAR(50) PRIMARY KEY,                 -- é€€æ¬¾å•å·
    order_id VARCHAR(50) NOT NULL REFERENCES orders(id),
    
    -- é€€æ¬¾ä¿¡æ¯
    refund_amount DECIMAL(10, 2) NOT NULL,      -- é€€æ¬¾é‡‘é¢
    refund_reason TEXT,                         -- é€€æ¬¾åŸå› 
    refund_type VARCHAR(20) NOT NULL,           -- full(å…¨é¢) | partial(éƒ¨åˆ†)
    
    -- çŠ¶æ€
    status VARCHAR(20) DEFAULT 'pending',       -- pending | processing | success | failed
    
    -- ç¬¬ä¸‰æ–¹ä¿¡æ¯
    refund_transaction_id VARCHAR(100),         -- ç¬¬ä¸‰æ–¹é€€æ¬¾äº¤æ˜“å·
    
    -- æ“ä½œä¿¡æ¯
    created_by UUID REFERENCES users(id),       -- æ“ä½œäººï¼ˆç”¨æˆ·ç”³è¯·æˆ–ç®¡ç†å‘˜æ“ä½œï¼‰
    approved_by UUID REFERENCES users(id),      -- å®¡æ‰¹äºº
    
    -- æ—¶é—´ä¿¡æ¯
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    approved_at TIMESTAMP,
    completed_at TIMESTAMP,
    
    -- ç´¢å¼•
    INDEX idx_order_id (order_id),
    INDEX idx_status (status),
    INDEX idx_created_at (created_at)
);
```

### payment_info å­—æ®µç»“æ„

```json
{
  // æ”¯ä»˜å®
  "alipay": {
    "qr_code": "https://qr.alipay.com/...",      // æ”¯ä»˜äºŒç»´ç é“¾æ¥
    "pay_url": "https://openapi.alipay.com/...", // æ”¯ä»˜é“¾æ¥
    "out_trade_no": "ORD20240126123456789"       // å•†æˆ·è®¢å•å·
  },
  
  // å¾®ä¿¡æ”¯ä»˜
  "wechat": {
    "code_url": "weixin://wxpay/...",            // äºŒç»´ç å†…å®¹
    "qr_code_image": "data:image/png;base64,..." // Base64å›¾ç‰‡
  },
  
  // Stripe
  "stripe": {
    "session_id": "cs_test_...",                 // Checkout Session ID
    "payment_intent": "pi_...",                  // Payment Intent ID
    "checkout_url": "https://checkout.stripe.com/..."
  }
}
```

---

## ğŸ“¡ APIæ¥å£è®¾è®¡

### æ¥å£åˆ—è¡¨æ¦‚è§ˆ

| æ–¹æ³• | ç«¯ç‚¹ | æè¿° | è®¤è¯ |
|------|------|------|------|
| POST | `/api/v1/orders/create` | åˆ›å»ºè®¢å• | ç”¨æˆ· |
| GET | `/api/v1/orders/:id` | è·å–è®¢å•è¯¦æƒ… | ç”¨æˆ· |
| GET | `/api/v1/orders/list` | è·å–è®¢å•åˆ—è¡¨ | ç”¨æˆ· |
| POST | `/api/v1/orders/:id/pay` | å‘èµ·æ”¯ä»˜ | ç”¨æˆ· |
| POST | `/api/v1/orders/:id/cancel` | å–æ¶ˆè®¢å• | ç”¨æˆ· |
| GET | `/api/v1/orders/:id/status` | æŸ¥è¯¢è®¢å•çŠ¶æ€ | ç”¨æˆ· |
| POST | `/api/v1/payment/callback/alipay` | æ”¯ä»˜å®å›è°ƒ | æ—  |
| POST | `/api/v1/payment/callback/wechat` | å¾®ä¿¡å›è°ƒ | æ—  |
| POST | `/api/v1/payment/callback/stripe` | Stripeå›è°ƒ | æ—  |
| POST | `/api/v1/orders/:id/refund` | ç”³è¯·é€€æ¬¾ | ç”¨æˆ· |

---

### 1. åˆ›å»ºè®¢å•

**ç«¯ç‚¹ï¼š** `POST /api/v1/orders/create`

**è¯·æ±‚å¤´ï¼š**
```
Authorization: Bearer {accessToken}
Content-Type: application/json
```

**è¯·æ±‚ä½“ï¼š**
```json
{
  "plan_id": "pro_monthly",
  "coupon_code": "WELCOME2024",  // å¯é€‰
  "payment_method": "alipay"     // alipay | wechat | stripe
}
```

**å“åº”ç¤ºä¾‹ï¼ˆæˆåŠŸï¼‰ï¼š**
```json
{
  "success": true,
  "message": "è®¢å•åˆ›å»ºæˆåŠŸ",
  "data": {
    "order_id": "ORD20240126123456789",
    "plan": {
      "id": "pro_monthly",
      "name": "ä¸“ä¸šç‰ˆ",
      "billing_cycle": "monthly"
    },
    "amount": {
      "original_price": 99.00,
      "discount_amount": 20.00,
      "final_price": 79.00,
      "currency": "CNY"
    },
    "discount_breakdown": {
      "coupon": {
        "code": "WELCOME2024",
        "amount": 20.00,
        "label": "æ–°ç”¨æˆ·ä¼˜æƒ "
      },
      "invite": null
    },
    "status": "pending",
    "expire_at": "2024-01-26T12:50:00Z",
    "created_at": "2024-01-26T12:35:00Z"
  }
}
```

**å“åº”ç¤ºä¾‹ï¼ˆå¤±è´¥ - å¥—é¤ä¸å­˜åœ¨ï¼‰ï¼š**
```json
{
  "success": false,
  "error": {
    "code": "PLAN_NOT_FOUND",
    "message": "å¥—é¤ä¸å­˜åœ¨æˆ–å·²ä¸‹æ¶"
  }
}
```

**å“åº”ç¤ºä¾‹ï¼ˆå¤±è´¥ - ä¼˜æƒ åˆ¸æ— æ•ˆï¼‰ï¼š**
```json
{
  "success": false,
  "error": {
    "code": "INVALID_COUPON",
    "message": "ä¼˜æƒ åˆ¸å·²è¿‡æœŸæˆ–å·²è¾¾åˆ°ä½¿ç”¨ä¸Šé™"
  }
}
```

**å“åº”ç¤ºä¾‹ï¼ˆå¤±è´¥ - å·²æœ‰å¾…æ”¯ä»˜è®¢å•ï¼‰ï¼š**
```json
{
  "success": false,
  "error": {
    "code": "PENDING_ORDER_EXISTS",
    "message": "æ‚¨æœ‰å¾…æ”¯ä»˜çš„è®¢å•ï¼Œè¯·å…ˆå®Œæˆæ”¯ä»˜æˆ–å–æ¶ˆ",
    "data": {
      "pending_order_id": "ORD20240126123400000"
    }
  }
}
```

---

### 2. å‘èµ·æ”¯ä»˜

**ç«¯ç‚¹ï¼š** `POST /api/v1/orders/:id/pay`

**è¯·æ±‚å¤´ï¼š**
```
Authorization: Bearer {accessToken}
```

**è¯·æ±‚ä½“ï¼š**
```json
{
  "payment_method": "alipay",  // alipay | wechat | stripe
  "return_url": "https://yourdomain.com/payment/success"  // å¯é€‰ï¼Œæ”¯ä»˜æˆåŠŸåè·³è½¬åœ°å€
}
```

**å“åº”ç¤ºä¾‹ï¼ˆæ”¯ä»˜å®ï¼‰ï¼š**
```json
{
  "success": true,
  "data": {
    "order_id": "ORD20240126123456789",
    "payment_method": "alipay",
    "payment_info": {
      "qr_code": "https://qr.alipay.com/bax08888abcdefg",
      "pay_url": "https://openapi.alipay.com/gateway.do?...",
      "expire_at": "2024-01-26T12:50:00Z"
    },
    "instructions": "è¯·ä½¿ç”¨æ”¯ä»˜å®æ‰«æäºŒç»´ç å®Œæˆæ”¯ä»˜ï¼Œæˆ–ç‚¹å‡»æ”¯ä»˜é“¾æ¥è·³è½¬"
  }
}
```

**å“åº”ç¤ºä¾‹ï¼ˆå¾®ä¿¡æ”¯ä»˜ï¼‰ï¼š**
```json
{
  "success": true,
  "data": {
    "order_id": "ORD20240126123456789",
    "payment_method": "wechat",
    "payment_info": {
      "code_url": "weixin://wxpay/bizpayurl?pr=abcdefg",
      "qr_code_image": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAA...",
      "expire_at": "2024-01-26T12:50:00Z"
    },
    "instructions": "è¯·ä½¿ç”¨å¾®ä¿¡æ‰«æäºŒç»´ç å®Œæˆæ”¯ä»˜"
  }
}
```

**å“åº”ç¤ºä¾‹ï¼ˆStripeï¼‰ï¼š**
```json
{
  "success": true,
  "data": {
    "order_id": "ORD20240126123456789",
    "payment_method": "stripe",
    "payment_info": {
      "session_id": "cs_test_a1b2c3d4e5f6g7h8",
      "checkout_url": "https://checkout.stripe.com/pay/cs_test_a1b2c3d4e5f6g7h8",
      "public_key": "pk_test_..."
    },
    "instructions": "ç‚¹å‡»é“¾æ¥è·³è½¬åˆ°Stripeæ”¯ä»˜é¡µé¢"
  }
}
```

**é”™è¯¯å“åº”ï¼š**
```json
{
  "success": false,
  "error": {
    "code": "ORDER_NOT_FOUND",
    "message": "è®¢å•ä¸å­˜åœ¨"
  }
}
```

```json
{
  "success": false,
  "error": {
    "code": "ORDER_ALREADY_PAID",
    "message": "è®¢å•å·²æ”¯ä»˜"
  }
}
```

---

### 3. è·å–è®¢å•è¯¦æƒ…

**ç«¯ç‚¹ï¼š** `GET /api/v1/orders/:id`

**è¯·æ±‚å¤´ï¼š**
```
Authorization: Bearer {accessToken}
```

**å“åº”ç¤ºä¾‹ï¼š**
```json
{
  "success": true,
  "data": {
    "order_id": "ORD20240126123456789",
    "user": {
      "id": "user_uuid",
      "email": "user@example.com"
    },
    "plan": {
      "id": "pro_monthly",
      "name": "ä¸“ä¸šç‰ˆ",
      "billing_cycle": "monthly",
      "snapshot": {
        // å®Œæ•´çš„å¥—é¤å¿«ç…§
      }
    },
    "amount": {
      "original_price": 99.00,
      "discount_amount": 20.00,
      "final_price": 79.00,
      "currency": "CNY"
    },
    "status": "paid",
    "payment_status": "success",
    "payment_method": "alipay",
    "transaction_id": "2024012622001234567890",
    "created_at": "2024-01-26T12:35:00Z",
    "paid_at": "2024-01-26T12:38:45Z",
    "expire_at": "2024-01-26T12:50:00Z"
  }
}
```

---

### 4. è·å–è®¢å•åˆ—è¡¨

**ç«¯ç‚¹ï¼š** `GET /api/v1/orders/list`

**è¯·æ±‚å¤´ï¼š**
```
Authorization: Bearer {accessToken}
```

**æŸ¥è¯¢å‚æ•°ï¼š**

| å‚æ•° | ç±»å‹ | å¿…å¡« | è¯´æ˜ |
|------|------|------|------|
| status | string | å¦ | è®¢å•çŠ¶æ€ç­›é€‰ |
| page | integer | å¦ | é¡µç ï¼Œé»˜è®¤1 |
| limit | integer | å¦ | æ¯é¡µæ•°é‡ï¼Œé»˜è®¤20 |

**å“åº”ç¤ºä¾‹ï¼š**
```json
{
  "success": true,
  "data": [
    {
      "order_id": "ORD20240126123456789",
      "plan_name": "ä¸“ä¸šç‰ˆ",
      "amount": 79.00,
      "status": "paid",
      "payment_method": "alipay",
      "created_at": "2024-01-26T12:35:00Z",
      "paid_at": "2024-01-26T12:38:45Z"
    },
    {
      "order_id": "ORD20240125100000000",
      "plan_name": "åŸºç¡€ç‰ˆ",
      "amount": 49.00,
      "status": "expired",
      "payment_method": null,
      "created_at": "2024-01-25T10:00:00Z",
      "paid_at": null
    }
  ],
  "pagination": {
    "page": 1,
    "limit": 20,
    "total": 35,
    "total_pages": 2
  }
}
```

---

### 5. æŸ¥è¯¢è®¢å•çŠ¶æ€

**ç«¯ç‚¹ï¼š** `GET /api/v1/orders/:id/status`

**è¯·æ±‚å¤´ï¼š**
```
Authorization: Bearer {accessToken}
```

**å“åº”ç¤ºä¾‹ï¼š**
```json
{
  "success": true,
  "data": {
    "order_id": "ORD20240126123456789",
    "status": "paid",
    "payment_status": "success",
    "paid_at": "2024-01-26T12:38:45Z",
    "subscription": {
      "id": "sub_uuid",
      "status": "active",
      "expire_date": "2024-02-26"
    }
  }
}
```

**ç”¨é€”ï¼š** å‰ç«¯è½®è¯¢æ­¤æ¥å£æ£€æŸ¥æ”¯ä»˜æ˜¯å¦å®Œæˆ

---

### 6. å–æ¶ˆè®¢å•

**ç«¯ç‚¹ï¼š** `POST /api/v1/orders/:id/cancel`

**è¯·æ±‚å¤´ï¼š**
```
Authorization: Bearer {accessToken}
```

**è¯·æ±‚ä½“ï¼š**
```json
{
  "reason": "ä¸æƒ³è´­ä¹°äº†"  // å¯é€‰
}
```

**å“åº”ç¤ºä¾‹ï¼š**
```json
{
  "success": true,
  "message": "è®¢å•å·²å–æ¶ˆ"
}
```

**é”™è¯¯å“åº”ï¼š**
```json
{
  "success": false,
  "error": {
    "code": "CANNOT_CANCEL_PAID_ORDER",
    "message": "å·²æ”¯ä»˜çš„è®¢å•ä¸èƒ½å–æ¶ˆï¼Œè¯·ç”³è¯·é€€æ¬¾"
  }
}
```

---

### 7. æ”¯ä»˜å®å›è°ƒ

**ç«¯ç‚¹ï¼š** `POST /api/v1/payment/callback/alipay`

**è¯·æ±‚å¤´ï¼š** æ— ï¼ˆå…¬å¼€æ¥å£ï¼‰

**è¯·æ±‚ä½“ï¼š** è¡¨å•æ ¼å¼ï¼ˆapplication/x-www-form-urlencodedï¼‰

æ”¯ä»˜å®å›è°ƒå‚æ•°ï¼š
```
out_trade_no=ORD20240126123456789
trade_no=2024012622001234567890
trade_status=TRADE_SUCCESS
total_amount=79.00
...å…¶ä»–å‚æ•°
sign=...ç­¾å
```

**å“åº”ï¼š** å¿…é¡»è¿”å›çº¯æ–‡æœ¬ "success" æˆ– "failure"

```
success
```

---

### 8. å¾®ä¿¡æ”¯ä»˜å›è°ƒ

**ç«¯ç‚¹ï¼š** `POST /api/v1/payment/callback/wechat`

**è¯·æ±‚å¤´ï¼š** æ— ï¼ˆå…¬å¼€æ¥å£ï¼‰

**è¯·æ±‚ä½“ï¼š** XMLæ ¼å¼

```xml
<xml>
  <return_code>SUCCESS</return_code>
  <result_code>SUCCESS</result_code>
  <out_trade_no>ORD20240126123456789</out_trade_no>
  <transaction_id>4200001234567890</transaction_id>
  <total_fee>7900</total_fee>
  <sign>...</sign>
</xml>
```

**å“åº”ï¼š** XMLæ ¼å¼

```xml
<xml>
  <return_code>SUCCESS</return_code>
  <return_msg>OK</return_msg>
</xml>
```

---

### 9. Stripe Webhook

**ç«¯ç‚¹ï¼š** `POST /api/v1/payment/callback/stripe`

**è¯·æ±‚å¤´ï¼š**
```
Stripe-Signature: t=1234567890,v1=...
```

**è¯·æ±‚ä½“ï¼š** JSONæ ¼å¼

```json
{
  "id": "evt_...",
  "type": "checkout.session.completed",
  "data": {
    "object": {
      "id": "cs_test_...",
      "payment_status": "paid",
      "amount_total": 7900,
      "metadata": {
        "order_id": "ORD20240126123456789"
      }
    }
  }
}
```

**å“åº”ï¼š**
```json
{
  "received": true
}
```

---

### 10. ç”³è¯·é€€æ¬¾

**ç«¯ç‚¹ï¼š** `POST /api/v1/orders/:id/refund`

**è¯·æ±‚å¤´ï¼š**
```
Authorization: Bearer {accessToken}
```

**è¯·æ±‚ä½“ï¼š**
```json
{
  "reason": "å•†å“ä¸ç¬¦åˆé¢„æœŸ"
}
```

**å“åº”ç¤ºä¾‹ï¼š**
```json
{
  "success": true,
  "message": "é€€æ¬¾ç”³è¯·å·²æäº¤ï¼Œé¢„è®¡3-7ä¸ªå·¥ä½œæ—¥åˆ°è´¦",
  "data": {
    "refund_id": "REF20240126123456789",
    "order_id": "ORD20240126123456789",
    "refund_amount": 79.00,
    "status": "pending"
  }
}
```

---

## ğŸ’» åç«¯å®ç°

### ç›®å½•ç»“æ„

```
src/
â”œâ”€â”€ controllers/
â”‚   â”œâ”€â”€ OrderController.js         // è®¢å•æ§åˆ¶å™¨
â”‚   â””â”€â”€ PaymentCallbackController.js // æ”¯ä»˜å›è°ƒæ§åˆ¶å™¨
â”œâ”€â”€ services/
â”‚   â”œâ”€â”€ OrderService.js            // è®¢å•ä¸šåŠ¡é€»è¾‘
â”‚   â”œâ”€â”€ PaymentService.js          // æ”¯ä»˜æœåŠ¡ï¼ˆé›†æˆæ”¯ä»˜å®ã€å¾®ä¿¡ã€Stripeï¼‰
â”‚   â”œâ”€â”€ AlipayService.js           // æ”¯ä»˜å®æœåŠ¡
â”‚   â”œâ”€â”€ WechatPayService.js        // å¾®ä¿¡æ”¯ä»˜æœåŠ¡
â”‚   â”œâ”€â”€ StripeService.js           // StripeæœåŠ¡
â”‚   â””â”€â”€ RefundService.js           // é€€æ¬¾æœåŠ¡
â”œâ”€â”€ models/
â”‚   â”œâ”€â”€ Order.js                   // è®¢å•æ¨¡å‹
â”‚   â”œâ”€â”€ PaymentCallback.js         // æ”¯ä»˜å›è°ƒæ¨¡å‹
â”‚   â””â”€â”€ Refund.js                  // é€€æ¬¾æ¨¡å‹
â”œâ”€â”€ middleware/
â”‚   â”œâ”€â”€ orderValidation.js         // è®¢å•éªŒè¯ä¸­é—´ä»¶
â”‚   â””â”€â”€ webhookValidation.js       // Webhookç­¾åéªŒè¯
â”œâ”€â”€ utils/
â”‚   â”œâ”€â”€ orderIdGenerator.js        // è®¢å•å·ç”Ÿæˆ
â”‚   â””â”€â”€ priceCalculator.js         // ä»·æ ¼è®¡ç®—
â”œâ”€â”€ jobs/
â”‚   â””â”€â”€ orderExpiration.js         // è®¢å•è¿‡æœŸä»»åŠ¡
â””â”€â”€ routes/
    â””â”€â”€ api/
        â””â”€â”€ v1/
            â”œâ”€â”€ orders.js          // è®¢å•è·¯ç”±
            â””â”€â”€ payment.js         // æ”¯ä»˜å›è°ƒè·¯ç”±
```

---

### 1. è®¢å•æ¨¡å‹ï¼ˆOrder.jsï¼‰

```javascript
// src/models/Order.js

const db = require('../config/database');
const redis = require('../config/redis');
const { generateOrderId } = require('../utils/orderIdGenerator');

class Order {
  /**
   * åˆ›å»ºè®¢å•
   */
  static async create(orderData) {
    const {
      userId, planId, planSnapshot, originalPrice, discountAmount,
      finalPrice, currency, couponCode, couponDiscount, inviteDiscount,
      paymentMethod, userIp, userAgent
    } = orderData;
    
    const orderId = generateOrderId();
    
    const result = await db.query(
      `INSERT INTO orders (
        id, user_id, plan_id, plan_snapshot,
        original_price, discount_amount, final_price, currency,
        coupon_code, coupon_discount, invite_discount,
        payment_method, user_ip, user_agent
      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14)
      RETURNING *`,
      [
        orderId, userId, planId, JSON.stringify(planSnapshot),
        originalPrice, discountAmount, finalPrice, currency,
        couponCode, couponDiscount, inviteDiscount,
        paymentMethod, userIp, userAgent
      ]
    );
    
    return result.rows[0];
  }
  
  /**
   * æ ¹æ®IDè·å–è®¢å•
   */
  static async findById(orderId) {
    const result = await db.query(
      'SELECT * FROM orders WHERE id = $1',
      [orderId]
    );
    
    return result.rows[0] || null;
  }
  
  /**
   * æ ¹æ®ç”¨æˆ·IDè·å–è®¢å•åˆ—è¡¨
   */
  static async findByUserId(userId, filters = {}) {
    const { status, page = 1, limit = 20 } = filters;
    const offset = (page - 1) * limit;
    
    let query = 'SELECT * FROM orders WHERE user_id = $1';
    const params = [userId];
    
    if (status) {
      query += ' AND status = $2';
      params.push(status);
    }
    
    query += ' ORDER BY created_at DESC LIMIT $' + (params.length + 1) + 
             ' OFFSET $' + (params.length + 2);
    params.push(limit, offset);
    
    const result = await db.query(query, params);
    
    // è·å–æ€»æ•°
    const countQuery = status
      ? 'SELECT COUNT(*) FROM orders WHERE user_id = $1 AND status = $2'
      : 'SELECT COUNT(*) FROM orders WHERE user_id = $1';
    const countParams = status ? [userId, status] : [userId];
    const countResult = await db.query(countQuery, countParams);
    
    return {
      orders: result.rows,
      total: parseInt(countResult.rows[0].count)
    };
  }
  
  /**
   * æ›´æ–°è®¢å•çŠ¶æ€
   */
  static async updateStatus(orderId, status, additionalData = {}) {
    const fields = ['status = $1'];
    const params = [status, orderId];
    let paramIndex = 2;
    
    // æ ¹æ®çŠ¶æ€æ›´æ–°å¯¹åº”çš„æ—¶é—´å­—æ®µ
    if (status === 'paid') {
      fields.push(`paid_at = CURRENT_TIMESTAMP`);
    } else if (status === 'cancelled') {
      fields.push(`cancelled_at = CURRENT_TIMESTAMP`);
    } else if (status === 'refunded') {
      fields.push(`refunded_at = CURRENT_TIMESTAMP`);
    }
    
    // æ·»åŠ é¢å¤–å­—æ®µ
    for (const [key, value] of Object.entries(additionalData)) {
      paramIndex++;
      fields.push(`${key} = $${paramIndex}`);
      params.push(value);
    }
    
    const query = `
      UPDATE orders 
      SET ${fields.join(', ')}
      WHERE id = $2
      RETURNING *
    `;
    
    const result = await db.query(query, params);
    return result.rows[0] || null;
  }
  
  /**
   * æ›´æ–°æ”¯ä»˜ä¿¡æ¯
   */
  static async updatePaymentInfo(orderId, paymentInfo, transactionId) {
    const result = await db.query(
      `UPDATE orders 
       SET payment_info = $1, transaction_id = $2
       WHERE id = $3
       RETURNING *`,
      [JSON.stringify(paymentInfo), transactionId, orderId]
    );
    
    return result.rows[0] || null;
  }
  
  /**
   * æ£€æŸ¥ç”¨æˆ·æ˜¯å¦æœ‰å¾…æ”¯ä»˜è®¢å•
   */
  static async hasPendingOrder(userId) {
    const result = await db.query(
      `SELECT id FROM orders 
       WHERE user_id = $1 AND status = 'pending' AND expire_at > NOW()
       LIMIT 1`,
      [userId]
    );
    
    return result.rows.length > 0 ? result.rows[0] : null;
  }
  
  /**
   * è·å–è¿‡æœŸçš„å¾…æ”¯ä»˜è®¢å•
   */
  static async getExpiredOrders(limit = 100) {
    const result = await db.query(
      `SELECT id FROM orders 
       WHERE status = 'pending' AND expire_at <= NOW()
       ORDER BY expire_at ASC
       LIMIT $1`,
      [limit]
    );
    
    return result.rows;
  }
  
  /**
   * æ‰¹é‡å–æ¶ˆè¿‡æœŸè®¢å•
   */
  static async cancelExpiredOrders(orderIds) {
    const result = await db.query(
      `UPDATE orders 
       SET status = 'expired', cancelled_at = CURRENT_TIMESTAMP
       WHERE id = ANY($1)
       RETURNING id`,
      [orderIds]
    );
    
    return result.rows.length;
  }
}

module.exports = Order;
```

---

### 2. è®¢å•æœåŠ¡ï¼ˆOrderService.jsï¼‰

```javascript
// src/services/OrderService.js

const Order = require('../models/Order');
const Plan = require('../models/Plan');
const Coupon = require('../models/Coupon');
const User = require('../models/User');
const { calculatePrice } = require('../utils/priceCalculator');

class OrderService {
  /**
   * åˆ›å»ºè®¢å•
   */
  static async createOrder(userId, orderData, userIp, userAgent) {
    const { plan_id, coupon_code, payment_method } = orderData;
    
    // 1. æ£€æŸ¥ç”¨æˆ·æ˜¯å¦æœ‰å¾…æ”¯ä»˜è®¢å•
    const pendingOrder = await Order.hasPendingOrder(userId);
    if (pendingOrder) {
      throw new Error('PENDING_ORDER_EXISTS', pendingOrder.id);
    }
    
    // 2. è·å–å¥—é¤ä¿¡æ¯
    const plan = await Plan.findById(plan_id);
    if (!plan || plan.status !== 'active') {
      throw new Error('å¥—é¤ä¸å­˜åœ¨æˆ–å·²ä¸‹æ¶');
    }
    
    // 3. è·å–ç”¨æˆ·ä¿¡æ¯ï¼ˆæ£€æŸ¥é‚€è¯·ä¼˜æƒ ï¼‰
    const user = await User.findById(userId);
    
    // 4. éªŒè¯å¹¶åº”ç”¨ä¼˜æƒ åˆ¸
    let coupon = null;
    if (coupon_code) {
      coupon = await Coupon.validate(coupon_code, userId, plan_id);
      if (!coupon.valid) {
        throw new Error(coupon.message);
      }
    }
    
    // 5. è®¡ç®—ä»·æ ¼
    const priceInfo = calculatePrice({
      planPrice: parseFloat(plan.price),
      coupon: coupon?.data,
      invitedBy: user.invited_by
    });
    
    // 6. åˆ›å»ºè®¢å•
    const order = await Order.create({
      userId,
      planId: plan_id,
      planSnapshot: plan,
      originalPrice: priceInfo.originalPrice,
      discountAmount: priceInfo.totalDiscount,
      finalPrice: priceInfo.finalPrice,
      currency: plan.currency || 'CNY',
      couponCode: coupon_code || null,
      couponDiscount: priceInfo.couponDiscount || 0,
      inviteDiscount: priceInfo.inviteDiscount || 0,
      paymentMethod: payment_method,
      userIp,
      userAgent
    });
    
    // 7. å¦‚æœä½¿ç”¨äº†ä¼˜æƒ åˆ¸ï¼Œè®°å½•ä½¿ç”¨
    if (coupon) {
      await Coupon.recordUsage(coupon_code, userId, order.id);
    }
    
    return this.formatOrder(order);
  }
  
  /**
   * è·å–è®¢å•è¯¦æƒ…
   */
  static async getOrderById(orderId, userId) {
    const order = await Order.findById(orderId);
    
    if (!order) {
      throw new Error('è®¢å•ä¸å­˜åœ¨');
    }
    
    // éªŒè¯è®¢å•æ‰€å±æƒ
    if (order.user_id !== userId) {
      throw new Error('æ— æƒè®¿é—®æ­¤è®¢å•');
    }
    
    return this.formatOrder(order);
  }
  
  /**
   * è·å–è®¢å•åˆ—è¡¨
   */
  static async getOrders(userId, filters) {
    const { orders, total } = await Order.findByUserId(userId, filters);
    
    return {
      orders: orders.map(order => this.formatOrderListItem(order)),
      pagination: {
        page: filters.page || 1,
        limit: filters.limit || 20,
        total,
        total_pages: Math.ceil(total / (filters.limit || 20))
      }
    };
  }
  
  /**
   * å–æ¶ˆè®¢å•
   */
  static async cancelOrder(orderId, userId, reason) {
    const order = await Order.findById(orderId);
    
    if (!order) {
      throw new Error('è®¢å•ä¸å­˜åœ¨');
    }
    
    if (order.user_id !== userId) {
      throw new Error('æ— æƒæ“ä½œæ­¤è®¢å•');
    }
    
    if (order.status !== 'pending') {
      throw new Error('åªèƒ½å–æ¶ˆå¾…æ”¯ä»˜çš„è®¢å•');
    }
    
    await Order.updateStatus(orderId, 'cancelled', {
      cancel_reason: reason
    });
    
    return true;
  }
  
  /**
   * æ ¼å¼åŒ–è®¢å•æ•°æ®
   */
  static formatOrder(order) {
    const planSnapshot = typeof order.plan_snapshot === 'string'
      ? JSON.parse(order.plan_snapshot)
      : order.plan_snapshot;
    
    return {
      order_id: order.id,
      user_id: order.user_id,
      plan: {
        id: order.plan_id,
        name: planSnapshot.name,
        billing_cycle: planSnapshot.billing_cycle,
        snapshot: planSnapshot
      },
      amount: {
        original_price: parseFloat(order.original_price),
        discount_amount: parseFloat(order.discount_amount),
        final_price: parseFloat(order.final_price),
        currency: order.currency
      },
      discount_breakdown: {
        coupon: order.coupon_code ? {
          code: order.coupon_code,
          amount: parseFloat(order.coupon_discount)
        } : null,
        invite: order.invite_discount > 0 ? {
          amount: parseFloat(order.invite_discount)
        } : null
      },
      status: order.status,
      payment_status: order.payment_status,
      payment_method: order.payment_method,
      transaction_id: order.transaction_id,
      created_at: order.created_at,
      paid_at: order.paid_at,
      cancelled_at: order.cancelled_at,
      expire_at: order.expire_at
    };
  }
  
  /**
   * æ ¼å¼åŒ–è®¢å•åˆ—è¡¨é¡¹ï¼ˆç®€åŒ–ç‰ˆï¼‰
   */
  static formatOrderListItem(order) {
    const planSnapshot = typeof order.plan_snapshot === 'string'
      ? JSON.parse(order.plan_snapshot)
      : order.plan_snapshot;
    
    return {
      order_id: order.id,
      plan_name: planSnapshot.name,
      amount: parseFloat(order.final_price),
      status: order.status,
      payment_method: order.payment_method,
      created_at: order.created_at,
      paid_at: order.paid_at
    };
  }
}

module.exports = OrderService;
```

---

### 3. ä»·æ ¼è®¡ç®—å·¥å…·ï¼ˆpriceCalculator.jsï¼‰

```javascript
// src/utils/priceCalculator.js

/**
 * è®¡ç®—è®¢å•ä»·æ ¼
 * @param {Object} params
 * @param {number} params.planPrice - å¥—é¤åŸä»·
 * @param {Object} params.coupon - ä¼˜æƒ åˆ¸ä¿¡æ¯
 * @param {string} params.invitedBy - é‚€è¯·äººID
 * @returns {Object} ä»·æ ¼è¯¦æƒ…
 */
function calculatePrice(params) {
  const { planPrice, coupon, invitedBy } = params;
  
  let originalPrice = planPrice;
  let couponDiscount = 0;
  let inviteDiscount = 0;
  
  // 1. è®¡ç®—ä¼˜æƒ åˆ¸æŠ˜æ‰£
  if (coupon && coupon.enabled) {
    if (coupon.type === 'percentage') {
      // ç™¾åˆ†æ¯”æŠ˜æ‰£
      couponDiscount = originalPrice * (coupon.value / 100);
    } else if (coupon.type === 'fixed_amount') {
      // å›ºå®šé‡‘é¢æŠ˜æ‰£
      couponDiscount = Math.min(coupon.value, originalPrice);
    }
  }
  
  // 2. è®¡ç®—é‚€è¯·ä¼˜æƒ ï¼ˆå¦‚æœæœ‰é‚€è¯·äººï¼‰
  if (invitedBy) {
    // å‡è®¾é‚€è¯·ä¼˜æƒ ä¸º5%
    const INVITE_DISCOUNT_RATE = 0.05;
    inviteDiscount = originalPrice * INVITE_DISCOUNT_RATE;
  }
  
  // 3. è®¡ç®—æ€»æŠ˜æ‰£å’Œæœ€ç»ˆä»·æ ¼
  const totalDiscount = couponDiscount + inviteDiscount;
  let finalPrice = originalPrice - totalDiscount;
  
  // 4. ç¡®ä¿ä»·æ ¼ä¸ä¸ºè´Ÿæ•°
  finalPrice = Math.max(finalPrice, 0);
  
  // 5. ä¿ç•™ä¸¤ä½å°æ•°
  return {
    originalPrice: parseFloat(originalPrice.toFixed(2)),
    couponDiscount: parseFloat(couponDiscount.toFixed(2)),
    inviteDiscount: parseFloat(inviteDiscount.toFixed(2)),
    totalDiscount: parseFloat(totalDiscount.toFixed(2)),
    finalPrice: parseFloat(finalPrice.toFixed(2))
  };
}

module.exports = {
  calculatePrice
};
```

---

### 4. è®¢å•å·ç”Ÿæˆå™¨ï¼ˆorderIdGenerator.jsï¼‰

```javascript
// src/utils/orderIdGenerator.js

/**
 * ç”Ÿæˆè®¢å•å·
 * æ ¼å¼ï¼šORD + å¹´æœˆæ—¥ + 9ä½éšæœºæ•°
 * ä¾‹å¦‚ï¼šORD20240126123456789
 */
function generateOrderId() {
  const now = new Date();
  const year = now.getFullYear();
  const month = String(now.getMonth() + 1).padStart(2, '0');
  const day = String(now.getDate()).padStart(2, '0');
  
  // ç”Ÿæˆ9ä½éšæœºæ•°
  const random = Math.floor(100000000 + Math.random() * 900000000);
  
  return `ORD${year}${month}${day}${random}`;
}

/**
 * ç”Ÿæˆé€€æ¬¾å•å·
 * æ ¼å¼ï¼šREF + å¹´æœˆæ—¥ + 9ä½éšæœºæ•°
 */
function generateRefundId() {
  const now = new Date();
  const year = now.getFullYear();
  const month = String(now.getMonth() + 1).padStart(2, '0');
  const day = String(now.getDate()).padStart(2, '0');
  
  const random = Math.floor(100000000 + Math.random() * 900000000);
  
  return `REF${year}${month}${day}${random}`;
}

module.exports = {
  generateOrderId,
  generateRefundId
};
```

---

### 5. æ”¯ä»˜å®æœåŠ¡ï¼ˆAlipayService.jsï¼‰

```javascript
// src/services/AlipayService.js

const AlipaySDK = require('alipay-sdk').default;
const AlipayFormData = require('alipay-sdk/lib/form').default;
const crypto = require('crypto');

class AlipayService {
  constructor() {
    this.sdk = new AlipaySDK({
      appId: process.env.ALIPAY_APP_ID,
      privateKey: process.env.ALIPAY_PRIVATE_KEY,
      alipayPublicKey: process.env.ALIPAY_PUBLIC_KEY,
      gateway: 'https://openapi.alipay.com/gateway.do',
      timeout: 5000,
      camelCase: true // è‡ªåŠ¨è½¬æ¢ä¸ºé©¼å³°å‘½å
    });
  }
  
  /**
   * åˆ›å»ºæ”¯ä»˜ï¼ˆç”µè„‘ç½‘ç«™æ”¯ä»˜ï¼‰
   */
  async createWebPayment(order) {
    const formData = new AlipayFormData();
    formData.setMethod('get');
    
    formData.addField('returnUrl', process.env.ALIPAY_RETURN_URL);
    formData.addField('notifyUrl', `${process.env.APP_URL}/api/v1/payment/callback/alipay`);
    
    const result = await this.sdk.exec(
      'alipay.trade.page.pay',
      {},
      {
        outTradeNo: order.id,
        productCode: 'FAST_INSTANT_TRADE_PAY',
        subject: `${order.plan_snapshot.name} - ${order.plan_snapshot.billing_cycle}`,
        totalAmount: order.final_price,
        body: `è®¢å•å·ï¼š${order.id}`
      },
      { formData }
    );
    
    return {
      pay_url: result,
      qr_code: result, // å¯ä»¥è½¬æ¢ä¸ºäºŒç»´ç 
      out_trade_no: order.id
    };
  }
  
  /**
   * åˆ›å»ºæ”¯ä»˜ï¼ˆå½“é¢ä»˜ - æ‰«ç æ”¯ä»˜ï¼‰
   */
  async createQRPayment(order) {
    const result = await this.sdk.exec('alipay.trade.precreate', {
      outTradeNo: order.id,
      subject: `${order.plan_snapshot.name} - ${order.plan_snapshot.billing_cycle}`,
      totalAmount: order.final_price,
      notifyUrl: `${process.env.APP_URL}/api/v1/payment/callback/alipay`
    });
    
    if (result.code !== '10000') {
      throw new Error(`æ”¯ä»˜å®æ”¯ä»˜åˆ›å»ºå¤±è´¥: ${result.msg}`);
    }
    
    return {
      qr_code: result.qrCode,
      out_trade_no: order.id
    };
  }
  
  /**
   * éªŒè¯å›è°ƒç­¾å
   */
  verifyCallback(params) {
    // å¤åˆ¶å‚æ•°ï¼Œç§»é™¤signå’Œsign_type
    const signParams = { ...params };
    delete signParams.sign;
    delete signParams.sign_type;
    
    // æŒ‰å­—æ¯æ’åº
    const sortedKeys = Object.keys(signParams).sort();
    const signStr = sortedKeys
      .map(key => `${key}=${signParams[key]}`)
      .join('&');
    
    // éªŒè¯ç­¾å
    const verify = crypto.createVerify('RSA-SHA256');
    verify.update(signStr, 'utf8');
    
    return verify.verify(
      process.env.ALIPAY_PUBLIC_KEY,
      params.sign,
      'base64'
    );
  }
  
  /**
   * æŸ¥è¯¢è®¢å•æ”¯ä»˜çŠ¶æ€
   */
  async queryOrder(orderId) {
    const result = await this.sdk.exec('alipay.trade.query', {
      outTradeNo: orderId
    });
    
    return {
      tradeStatus: result.tradeStatus,
      tradeNo: result.tradeNo,
      totalAmount: result.totalAmount,
      buyerPayAmount: result.buyerPayAmount
    };
  }
  
  /**
   * ç”³è¯·é€€æ¬¾
   */
  async refund(orderId, refundAmount, refundReason) {
    const result = await this.sdk.exec('alipay.trade.refund', {
      outTradeNo: orderId,
      refundAmount: refundAmount,
      refundReason: refundReason || 'ç”¨æˆ·ç”³è¯·é€€æ¬¾'
    });
    
    if (result.code !== '10000') {
      throw new Error(`é€€æ¬¾å¤±è´¥: ${result.msg || result.subMsg}`);
    }
    
    return {
      success: true,
      refundFee: result.refundFee,
      tradeNo: result.tradeNo
    };
  }
}

module.exports = new AlipayService();
```

---

### 6. å¾®ä¿¡æ”¯ä»˜æœåŠ¡ï¼ˆWechatPayService.jsï¼‰

```javascript
// src/services/WechatPayService.js

const WxPay = require('wechatpay-node-v3');
const fs = require('fs');
const QRCode = require('qrcode');

class WechatPayService {
  constructor() {
    this.pay = new WxPay({
      appid: process.env.WECHAT_APP_ID,
      mchid: process.env.WECHAT_MCH_ID,
      publicKey: fs.readFileSync(process.env.WECHAT_PUBLIC_KEY_PATH),
      privateKey: fs.readFileSync(process.env.WECHAT_PRIVATE_KEY_PATH),
      key: process.env.WECHAT_API_V3_KEY
    });
  }
  
  /**
   * åˆ›å»ºNativeæ”¯ä»˜ï¼ˆæ‰«ç æ”¯ä»˜ï¼‰
   */
  async createNativePayment(order) {
    try {
      const result = await this.pay.transactions_native({
        description: `${order.plan_snapshot.name} - ${order.plan_snapshot.billing_cycle}`,
        out_trade_no: order.id,
        notify_url: `${process.env.APP_URL}/api/v1/payment/callback/wechat`,
        amount: {
          total: Math.round(order.final_price * 100), // è½¬æ¢ä¸ºåˆ†
          currency: 'CNY'
        }
      });
      
      if (result.code_url) {
        // ç”ŸæˆäºŒç»´ç å›¾ç‰‡
        const qrCodeImage = await QRCode.toDataURL(result.code_url);
        
        return {
          code_url: result.code_url,
          qr_code_image: qrCodeImage
        };
      } else {
        throw new Error('å¾®ä¿¡æ”¯ä»˜åˆ›å»ºå¤±è´¥');
      }
    } catch (error) {
      console.error('WeChat Pay error:', error);
      throw new Error(`å¾®ä¿¡æ”¯ä»˜åˆ›å»ºå¤±è´¥: ${error.message}`);
    }
  }
  
  /**
   * éªŒè¯å›è°ƒç­¾å
   */
  verifyCallback(headers, body) {
    const signature = headers['wechatpay-signature'];
    const timestamp = headers['wechatpay-timestamp'];
    const nonce = headers['wechatpay-nonce'];
    const serial = headers['wechatpay-serial'];
    
    return this.pay.verifySign({
      signature,
      timestamp,
      nonce,
      serial,
      body
    });
  }
  
  /**
   * è§£å¯†å›è°ƒæ•°æ®
   */
  decryptCallback(encryptedData) {
    return this.pay.decipher_gcm(
      encryptedData.ciphertext,
      encryptedData.associated_data,
      encryptedData.nonce,
      process.env.WECHAT_API_V3_KEY
    );
  }
  
  /**
   * æŸ¥è¯¢è®¢å•
   */
  async queryOrder(orderId) {
    try {
      const result = await this.pay.query({
        out_trade_no: orderId
      });
      
      return {
        tradeState: result.trade_state,
        transactionId: result.transaction_id,
        amount: result.amount.total / 100 // è½¬æ¢ä¸ºå…ƒ
      };
    } catch (error) {
      throw new Error(`æŸ¥è¯¢å¤±è´¥: ${error.message}`);
    }
  }
  
  /**
   * ç”³è¯·é€€æ¬¾
   */
  async refund(orderId, transactionId, refundAmount, totalAmount) {
    try {
      const refundId = `REF${Date.now()}`;
      
      const result = await this.pay.refund({
        out_trade_no: orderId,
        out_refund_no: refundId,
        reason: 'ç”¨æˆ·ç”³è¯·é€€æ¬¾',
        notify_url: `${process.env.APP_URL}/api/v1/payment/refund-callback/wechat`,
        amount: {
          refund: Math.round(refundAmount * 100),
          total: Math.round(totalAmount * 100),
          currency: 'CNY'
        }
      });
      
      return {
        success: result.status === 'SUCCESS',
        refundId: result.out_refund_no,
        refundAmount: result.amount.refund / 100
      };
    } catch (error) {
      throw new Error(`é€€æ¬¾å¤±è´¥: ${error.message}`);
    }
  }
}

module.exports = new WechatPayService();
```

---

### 7. StripeæœåŠ¡ï¼ˆStripeService.jsï¼‰

```javascript
// src/services/StripeService.js

const stripe = require('stripe')(process.env.STRIPE_SECRET_KEY);

class StripeService {
  /**
   * åˆ›å»ºCheckout Session
   */
  async createCheckoutSession(order, userEmail) {
    try {
      const session = await stripe.checkout.sessions.create({
        payment_method_types: ['card'],
        line_items: [
          {
            price_data: {
              currency: 'usd', // Stripeä¸»è¦ç”¨äºå›½é™…æ”¯ä»˜
              product_data: {
                name: order.plan_snapshot.name,
                description: `${order.plan_snapshot.billing_cycle} subscription`
              },
              unit_amount: Math.round(order.final_price * 100) // è½¬æ¢ä¸ºåˆ†
            },
            quantity: 1
          }
        ],
        mode: 'payment',
        success_url: `${process.env.FRONTEND_URL}/payment/success?order_id=${order.id}`,
        cancel_url: `${process.env.FRONTEND_URL}/payment/cancel?order_id=${order.id}`,
        customer_email: userEmail,
        metadata: {
          order_id: order.id,
          user_id: order.user_id,
          plan_id: order.plan_id
        }
      });
      
      return {
        session_id: session.id,
        checkout_url: session.url,
        public_key: process.env.STRIPE_PUBLISHABLE_KEY
      };
    } catch (error) {
      throw new Error(`Stripeæ”¯ä»˜åˆ›å»ºå¤±è´¥: ${error.message}`);
    }
  }
  
  /**
   * éªŒè¯Webhookç­¾å
   */
  verifyWebhook(payload, signature) {
    try {
      const event = stripe.webhooks.constructEvent(
        payload,
        signature,
        process.env.STRIPE_WEBHOOK_SECRET
      );
      return event;
    } catch (error) {
      throw new Error(`Webhookç­¾åéªŒè¯å¤±è´¥: ${error.message}`);
    }
  }
  
  /**
   * æŸ¥è¯¢Payment Intent
   */
  async queryPaymentIntent(paymentIntentId) {
    try {
      const paymentIntent = await stripe.paymentIntents.retrieve(paymentIntentId);
      
      return {
        status: paymentIntent.status,
        amount: paymentIntent.amount / 100,
        currency: paymentIntent.currency
      };
    } catch (error) {
      throw new Error(`æŸ¥è¯¢å¤±è´¥: ${error.message}`);
    }
  }
  
  /**
   * åˆ›å»ºé€€æ¬¾
   */
  async createRefund(paymentIntentId, amount) {
    try {
      const refund = await stripe.refunds.create({
        payment_intent: paymentIntentId,
        amount: Math.round(amount * 100)
      });
      
      return {
        success: refund.status === 'succeeded',
        refundId: refund.id,
        amount: refund.amount / 100
      };
    } catch (error) {
      throw new Error(`é€€æ¬¾å¤±è´¥: ${error.message}`);
    }
  }
}

module.exports = new StripeService();
```

---

### 8. æ”¯ä»˜æœåŠ¡ç»Ÿä¸€æ¥å£ï¼ˆPaymentService.jsï¼‰

```javascript
// src/services/PaymentService.js

const Order = require('../models/Order');
const AlipayService = require('./AlipayService');
const WechatPayService = require('./WechatPayService');
const StripeService = require('./StripeService');
const SubscriptionService = require('./SubscriptionService');
const EmailService = require('./EmailService');

class PaymentService {
  /**
   * å‘èµ·æ”¯ä»˜
   */
  static async initiatePayment(orderId, paymentMethod, userEmail) {
    const order = await Order.findById(orderId);
    
    if (!order) {
      throw new Error('è®¢å•ä¸å­˜åœ¨');
    }
    
    if (order.status !== 'pending') {
      throw new Error('è®¢å•çŠ¶æ€ä¸å…è®¸æ”¯ä»˜');
    }
    
    if (new Date() > new Date(order.expire_at)) {
      await Order.updateStatus(orderId, 'expired');
      throw new Error('è®¢å•å·²è¿‡æœŸ');
    }
    
    let paymentInfo;
    
    switch (paymentMethod) {
      case 'alipay':
        paymentInfo = await AlipayService.createQRPayment(order);
        break;
        
      case 'wechat':
        paymentInfo = await WechatPayService.createNativePayment(order);
        break;
        
      case 'stripe':
        paymentInfo = await StripeService.createCheckoutSession(order, userEmail);
        break;
        
      default:
        throw new Error('ä¸æ”¯æŒçš„æ”¯ä»˜æ–¹å¼');
    }
    
    // æ›´æ–°è®¢å•æ”¯ä»˜ä¿¡æ¯
    await Order.updatePaymentInfo(orderId, paymentInfo, null);
    
    return {
      order_id: orderId,
      payment_method: paymentMethod,
      payment_info: paymentInfo,
      expire_at: order.expire_at,
      instructions: this.getPaymentInstructions(paymentMethod)
    };
  }
  
  /**
   * å¤„ç†æ”¯ä»˜æˆåŠŸ
   */
  static async handlePaymentSuccess(orderId, transactionId, paymentMethod) {
    const order = await Order.findById(orderId);
    
    if (!order) {
      throw new Error('è®¢å•ä¸å­˜åœ¨');
    }
    
    // é˜²æ­¢é‡å¤å¤„ç†
    if (order.status === 'paid') {
      console.log(`è®¢å• ${orderId} å·²æ”¯ä»˜ï¼Œè·³è¿‡é‡å¤å¤„ç†`);
      return { duplicate: true };
    }
    
    // ä½¿ç”¨äº‹åŠ¡å¤„ç†
    const client = await db.getClient();
    
    try {
      await client.query('BEGIN');
      
      // 1. æ›´æ–°è®¢å•çŠ¶æ€
      await Order.updateStatus(orderId, 'paid', {
        payment_status: 'success',
        transaction_id: transactionId
      });
      
      // 2. åˆ›å»ºè®¢é˜…
      const subscription = await SubscriptionService.createFromOrder(order);
      
      // 3. å¤„ç†é‚€è¯·è¿”åˆ©
      if (order.user.invited_by) {
        await this.processReferralCommission(order);
      }
      
      await client.query('COMMIT');
      
      // 4. å‘é€æ”¯ä»˜æˆåŠŸé‚®ä»¶
      await EmailService.sendPaymentSuccessEmail(order.user_email, {
        orderId: order.id,
        planName: order.plan_snapshot.name,
        amount: order.final_price,
        subscriptionId: subscription.id
      });
      
      return {
        success: true,
        subscription_id: subscription.id
      };
      
    } catch (error) {
      await client.query('ROLLBACK');
      console.error('å¤„ç†æ”¯ä»˜æˆåŠŸå¤±è´¥:', error);
      throw error;
    } finally {
      client.release();
    }
  }
  
  /**
   * å¤„ç†æ”¯ä»˜å¤±è´¥
   */
  static async handlePaymentFailed(orderId, reason) {
    await Order.updateStatus(orderId, 'pending', {
      payment_status: 'failed',
      note: reason
    });
  }
  
  /**
   * è·å–æ”¯ä»˜è¯´æ˜
   */
  static getPaymentInstructions(paymentMethod) {
    const instructions = {
      alipay: 'è¯·ä½¿ç”¨æ”¯ä»˜å®æ‰«æäºŒç»´ç å®Œæˆæ”¯ä»˜ï¼Œæˆ–ç‚¹å‡»æ”¯ä»˜é“¾æ¥è·³è½¬',
      wechat: 'è¯·ä½¿ç”¨å¾®ä¿¡æ‰«æäºŒç»´ç å®Œæˆæ”¯ä»˜',
      stripe: 'ç‚¹å‡»é“¾æ¥è·³è½¬åˆ°Stripeæ”¯ä»˜é¡µé¢ï¼Œæ”¯æŒä¿¡ç”¨å¡æ”¯ä»˜'
    };
    
    return instructions[paymentMethod] || '';
  }
  
  /**
   * å¤„ç†é‚€è¯·è¿”åˆ©
   */
  static async processReferralCommission(order) {
    // åœ¨é‚€è¯·è¿”åˆ©æ¨¡å—ä¸­å®ç°
    // è¿™é‡Œåªæ˜¯å ä½
    console.log(`å¤„ç†è®¢å• ${order.id} çš„é‚€è¯·è¿”åˆ©`);
  }
}

module.exports = PaymentService;
```

---

### 9. æ”¯ä»˜å›è°ƒæ§åˆ¶å™¨ï¼ˆPaymentCallbackController.jsï¼‰

```javascript
// src/controllers/PaymentCallbackController.js

const PaymentCallback = require('../models/PaymentCallback');
const AlipayService = require('../services/AlipayService');
const WechatPayService = require('../services/WechatPayService');
const StripeService = require('../services/StripeService');
const PaymentService = require('../services/PaymentService');

class PaymentCallbackController {
  /**
   * æ”¯ä»˜å®å›è°ƒ
   */
  static async alipayCallback(req, res) {
    const callbackData = req.body;
    const sourceIp = req.ip;
    
    try {
      // 1. è®°å½•å›è°ƒ
      const callback = await PaymentCallback.create({
        orderId: callbackData.out_trade_no,
        paymentMethod: 'alipay',
        callbackData,
        sourceIp
      });
      
      // 2. éªŒè¯ç­¾å
      const isValid = AlipayService.verifyCallback(callbackData);
      
      await PaymentCallback.updateVerification(callback.id, isValid, 
        isValid ? 'ç­¾åéªŒè¯é€šè¿‡' : 'ç­¾åéªŒè¯å¤±è´¥'
      );
      
      if (!isValid) {
        console.error('æ”¯ä»˜å®å›è°ƒç­¾åéªŒè¯å¤±è´¥');
        return res.send('failure');
      }
      
      // 3. å¤„ç†æ”¯ä»˜ç»“æœ
      const { out_trade_no, trade_status, trade_no } = callbackData;
      
      if (trade_status === 'TRADE_SUCCESS' || trade_status === 'TRADE_FINISHED') {
        // æ”¯ä»˜æˆåŠŸ
        await PaymentService.handlePaymentSuccess(
          out_trade_no,
          trade_no,
          'alipay'
        );
        
        await PaymentCallback.updateProcessed(callback.id, true, 'å¤„ç†æˆåŠŸ');
      } else {
        // å…¶ä»–çŠ¶æ€
        await PaymentCallback.updateProcessed(callback.id, true, 
          `äº¤æ˜“çŠ¶æ€: ${trade_status}`
        );
      }
      
      return res.send('success');
      
    } catch (error) {
      console.error('å¤„ç†æ”¯ä»˜å®å›è°ƒå¤±è´¥:', error);
      
      if (callback) {
        await PaymentCallback.updateProcessed(callback.id, false, error.message);
      }
      
      return res.send('failure');
    }
  }
  
  /**
   * å¾®ä¿¡æ”¯ä»˜å›è°ƒ
   */
  static async wechatCallback(req, res) {
    const headers = req.headers;
    const body = req.body;
    const sourceIp = req.ip;
    
    try {
      // 1. éªŒè¯ç­¾å
      const isValid = WechatPayService.verifyCallback(headers, body);
      
      if (!isValid) {
        console.error('å¾®ä¿¡æ”¯ä»˜å›è°ƒç­¾åéªŒè¯å¤±è´¥');
        return res.status(401).json({
          code: 'FAIL',
          message: 'ç­¾åéªŒè¯å¤±è´¥'
        });
      }
      
      // 2. è§£å¯†æ•°æ®
      const decryptedData = WechatPayService.decryptCallback(body.resource);
      const callbackData = JSON.parse(decryptedData);
      
      // 3. è®°å½•å›è°ƒ
      const callback = await PaymentCallback.create({
        orderId: callbackData.out_trade_no,
        paymentMethod: 'wechat',
        callbackData,
        sourceIp,
        signatureValid: true
      });
      
      // 4. å¤„ç†æ”¯ä»˜ç»“æœ
      if (callbackData.trade_state === 'SUCCESS') {
        await PaymentService.handlePaymentSuccess(
          callbackData.out_trade_no,
          callbackData.transaction_id,
          'wechat'
        );
        
        await PaymentCallback.updateProcessed(callback.id, true, 'å¤„ç†æˆåŠŸ');
      }
      
      return res.json({
        code: 'SUCCESS',
        message: 'æˆåŠŸ'
      });
      
    } catch (error) {
      console.error('å¤„ç†å¾®ä¿¡æ”¯ä»˜å›è°ƒå¤±è´¥:', error);
      
      return res.status(500).json({
        code: 'FAIL',
        message: error.message
      });
    }
  }
  
  /**
   * Stripe Webhook
   */
  static async stripeWebhook(req, res) {
    const signature = req.headers['stripe-signature'];
    const payload = req.body;
    const sourceIp = req.ip;
    
    try {
      // 1. éªŒè¯Webhook
      const event = StripeService.verifyWebhook(payload, signature);
      
      // 2. è®°å½•å›è°ƒ
      const callback = await PaymentCallback.create({
        orderId: event.data.object.metadata?.order_id,
        paymentMethod: 'stripe',
        callbackData: event,
        sourceIp,
        signatureValid: true
      });
      
      // 3. å¤„ç†ä¸åŒç±»å‹çš„äº‹ä»¶
      switch (event.type) {
        case 'checkout.session.completed':
          const session = event.data.object;
          
          if (session.payment_status === 'paid') {
            await PaymentService.handlePaymentSuccess(
              session.metadata.order_id,
              session.payment_intent,
              'stripe'
            );
          }
          break;
          
        case 'payment_intent.payment_failed':
          const paymentIntent = event.data.object;
          await PaymentService.handlePaymentFailed(
            paymentIntent.metadata.order_id,
            'æ”¯ä»˜å¤±è´¥'
          );
          break;
          
        default:
          console.log(`æœªå¤„ç†çš„Stripeäº‹ä»¶ç±»å‹: ${event.type}`);
      }
      
      await PaymentCallback.updateProcessed(callback.id, true, 'å¤„ç†æˆåŠŸ');
      
      return res.json({ received: true });
      
    } catch (error) {
      console.error('å¤„ç†Stripe Webhookå¤±è´¥:', error);
      return res.status(400).json({ error: error.message });
    }
  }
}

module.exports = PaymentCallbackController;
```

---

### 10. è®¢å•è¿‡æœŸå®šæ—¶ä»»åŠ¡ï¼ˆorderExpiration.jsï¼‰

```javascript
// src/jobs/orderExpiration.js

const cron = require('node-cron');
const Order = require('../models/Order');

/**
 * å®šæ—¶ä»»åŠ¡ï¼šå¤„ç†è¿‡æœŸè®¢å•
 * æ¯5åˆ†é’Ÿæ‰§è¡Œä¸€æ¬¡
 */
function startOrderExpirationJob() {
  cron.schedule('*/5 * * * *', async () => {
    try {
      console.log('[è®¢å•è¿‡æœŸä»»åŠ¡] å¼€å§‹æ‰§è¡Œ...');
      
      // 1. è·å–è¿‡æœŸçš„å¾…æ”¯ä»˜è®¢å•
      const expiredOrders = await Order.getExpiredOrders(100);
      
      if (expiredOrders.length === 0) {
        console.log('[è®¢å•è¿‡æœŸä»»åŠ¡] æ²¡æœ‰è¿‡æœŸè®¢å•');
        return;
      }
      
      console.log(`[è®¢å•è¿‡æœŸä»»åŠ¡] å‘ç° ${expiredOrders.length} ä¸ªè¿‡æœŸè®¢å•`);
      
      // 2. æ‰¹é‡å–æ¶ˆè®¢å•
      const orderIds = expiredOrders.map(o => o.id);
      const cancelledCount = await Order.cancelExpiredOrders(orderIds);
      
      console.log(`[è®¢å•è¿‡æœŸä»»åŠ¡] æˆåŠŸå–æ¶ˆ ${cancelledCount} ä¸ªè®¢å•`);
      
    } catch (error) {
      console.error('[è®¢å•è¿‡æœŸä»»åŠ¡] æ‰§è¡Œå¤±è´¥:', error);
    }
  });
  
  console.log('è®¢å•è¿‡æœŸå®šæ—¶ä»»åŠ¡å·²å¯åŠ¨ï¼ˆæ¯5åˆ†é’Ÿæ‰§è¡Œä¸€æ¬¡ï¼‰');
}

module.exports = {
  startOrderExpirationJob
};
```

---

### 11. è®¢å•æ§åˆ¶å™¨ï¼ˆOrderController.jsï¼‰

```javascript
// src/controllers/OrderController.js

const OrderService = require('../services/OrderService');
const PaymentService = require('../services/PaymentService');
const { successResponse, errorResponse } = require('../utils/response');

class OrderController {
  /**
   * åˆ›å»ºè®¢å•
   */
  static async createOrder(req, res) {
    try {
      const userId = req.user.userId;
      const userIp = req.ip;
      const userAgent = req.headers['user-agent'];
      
      const order = await OrderService.createOrder(
        userId,
        req.body,
        userIp,
        userAgent
      );
      
      return successResponse(res, order, 'è®¢å•åˆ›å»ºæˆåŠŸ', 201);
      
    } catch (error) {
      console.error('åˆ›å»ºè®¢å•å¤±è´¥:', error);
      
      if (error.message === 'PENDING_ORDER_EXISTS') {
        return errorResponse(res, 400, 'PENDING_ORDER_EXISTS', 
          'æ‚¨æœ‰å¾…æ”¯ä»˜çš„è®¢å•ï¼Œè¯·å…ˆå®Œæˆæ”¯ä»˜æˆ–å–æ¶ˆ', {
            pending_order_id: error.orderId
          });
      }
      
      if (error.message.includes('å¥—é¤')) {
        return errorResponse(res, 404, 'PLAN_NOT_FOUND', error.message);
      }
      
      if (error.message.includes('ä¼˜æƒ åˆ¸')) {
        return errorResponse(res, 400, 'INVALID_COUPON', error.message);
      }
      
      return errorResponse(res, 500, 'INTERNAL_ERROR', 'åˆ›å»ºè®¢å•å¤±è´¥');
    }
  }
  
  /**
   * è·å–è®¢å•è¯¦æƒ…
   */
  static async getOrder(req, res) {
    try {
      const { id } = req.params;
      const userId = req.user.userId;
      
      const order = await OrderService.getOrderById(id, userId);
      
      return successResponse(res, order);
      
    } catch (error) {
      if (error.message === 'è®¢å•ä¸å­˜åœ¨') {
        return errorResponse(res, 404, 'ORDER_NOT_FOUND', error.message);
      }
      
      if (error.message === 'æ— æƒè®¿é—®æ­¤è®¢å•') {
        return errorResponse(res, 403, 'FORBIDDEN', error.message);
      }
      
      return errorResponse(res, 500, 'INTERNAL_ERROR', 'è·å–è®¢å•å¤±è´¥');
    }
  }
  
  /**
   * è·å–è®¢å•åˆ—è¡¨
   */
  static async getOrders(req, res) {
    try {
      const userId = req.user.userId;
      const filters = {
        status: req.query.status,
        page: parseInt(req.query.page) || 1,
        limit: parseInt(req.query.limit) || 20
      };
      
      const result = await OrderService.getOrders(userId, filters);
      
      return successResponse(res, result.orders, null, 200, {
        pagination: result.pagination
      });
      
    } catch (error) {
      console.error('è·å–è®¢å•åˆ—è¡¨å¤±è´¥:', error);
      return errorResponse(res, 500, 'INTERNAL_ERROR', 'è·å–è®¢å•åˆ—è¡¨å¤±è´¥');
    }
  }
  
  /**
   * å‘èµ·æ”¯ä»˜
   */
  static async initiatePayment(req, res) {
    try {
      const { id } = req.params;
      const { payment_method, return_url } = req.body;
      const userEmail = req.user.email;
      
      const result = await PaymentService.initiatePayment(
        id,
        payment_method,
        userEmail
      );
      
      return successResponse(res, result);
      
    } catch (error) {
      console.error('å‘èµ·æ”¯ä»˜å¤±è´¥:', error);
      
      if (error.message === 'è®¢å•ä¸å­˜åœ¨') {
        return errorResponse(res, 404, 'ORDER_NOT_FOUND', error.message);
      }
      
      if (error.message.includes('çŠ¶æ€')) {
        return errorResponse(res, 400, 'INVALID_ORDER_STATUS', error.message);
      }
      
      if (error.message.includes('è¿‡æœŸ')) {
        return errorResponse(res, 400, 'ORDER_EXPIRED', error.message);
      }
      
      return errorResponse(res, 500, 'PAYMENT_ERROR', 'å‘èµ·æ”¯ä»˜å¤±è´¥');
    }
  }
  
  /**
   * æŸ¥è¯¢è®¢å•çŠ¶æ€
   */
  static async getOrderStatus(req, res) {
    try {
      const { id } = req.params;
      const userId = req.user.userId;
      
      const order = await OrderService.getOrderById(id, userId);
      
      const response = {
        order_id: order.order_id,
        status: order.status,
        payment_status: order.payment_status,
        paid_at: order.paid_at
      };
      
      // å¦‚æœå·²æ”¯ä»˜ï¼Œè¿”å›è®¢é˜…ä¿¡æ¯
      if (order.status === 'paid') {
        const subscription = await SubscriptionService.getByUserId(userId);
        response.subscription = {
          id: subscription.id,
          status: subscription.status,
          expire_date: subscription.expire_date
        };
      }
      
      return successResponse(res, response);
      
    } catch (error) {
      return errorResponse(res, 500, 'INTERNAL_ERROR', 'æŸ¥è¯¢è®¢å•çŠ¶æ€å¤±è´¥');
    }
  }
  
  /**
   * å–æ¶ˆè®¢å•
   */
  static async cancelOrder(req, res) {
    try {
      const { id } = req.params;
      const userId = req.user.userId;
      const { reason } = req.body;
      
      await OrderService.cancelOrder(id, userId, reason);
      
      return successResponse(res, null, 'è®¢å•å·²å–æ¶ˆ');
      
    } catch (error) {
      if (error.message === 'è®¢å•ä¸å­˜åœ¨') {
        return errorResponse(res, 404, 'ORDER_NOT_FOUND', error.message);
      }
      
      if (error.message.includes('åªèƒ½å–æ¶ˆ')) {
        return errorResponse(res, 400, 'CANNOT_CANCEL_PAID_ORDER', error.message);
      }
      
      return errorResponse(res, 500, 'INTERNAL_ERROR', 'å–æ¶ˆè®¢å•å¤±è´¥');
    }
  }
}

module.exports = OrderController;
```

---

## ğŸ§ª æµ‹è¯•ç”¨ä¾‹

### 1. å•å…ƒæµ‹è¯•

```javascript
// tests/unit/OrderService.test.js

const OrderService = require('../../src/services/OrderService');
const Order = require('../../src/models/Order');
const Plan = require('../../src/models/Plan');

jest.mock('../../src/models/Order');
jest.mock('../../src/models/Plan');

describe('OrderService', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });
  
  describe('createOrder', () => {
    it('åº”è¯¥æˆåŠŸåˆ›å»ºè®¢å•', async () => {
      const userId = 'user-123';
      const orderData = {
        plan_id: 'pro_monthly',
        payment_method: 'alipay'
      };
      
      // Mockæ•°æ®
      Order.hasPendingOrder.mockResolvedValue(null);
      Plan.findById.mockResolvedValue({
        id: 'pro_monthly',
        name: 'ä¸“ä¸šç‰ˆ',
        price: '99.00',
        status: 'active'
      });
      Order.create.mockResolvedValue({
        id: 'ORD20240126123456789',
        user_id: userId,
        final_price: '99.00'
      });
      
      const result = await OrderService.createOrder(userId, orderData, '127.0.0.1', 'test');
      
      expect(result.order_id).toBe('ORD20240126123456789');
      expect(Order.create).toHaveBeenCalled();
    });
    
    it('æœ‰å¾…æ”¯ä»˜è®¢å•æ—¶åº”è¯¥æŠ›å‡ºé”™è¯¯', async () => {
      Order.hasPendingOrder.mockResolvedValue({ id: 'ORD_PENDING' });
      
      await expect(
        OrderService.createOrder('user-123', {}, '127.0.0.1', 'test')
      ).rejects.toThrow('PENDING_ORDER_EXISTS');
    });
  });
});
```

---

## ğŸš€ éƒ¨ç½²è¯´æ˜

### ç¯å¢ƒå˜é‡é…ç½®

```.env
# æ”¯ä»˜å®é…ç½®
ALIPAY_APP_ID=your_app_id
ALIPAY_PRIVATE_KEY="-----BEGIN RSA PRIVATE KEY-----\n...\n-----END RSA PRIVATE KEY-----"
ALIPAY_PUBLIC_KEY="-----BEGIN PUBLIC KEY-----\n...\n-----END PUBLIC KEY-----"
ALIPAY_RETURN_URL=https://yourdomain.com/payment/return

# å¾®ä¿¡æ”¯ä»˜é…ç½®
WECHAT_APP_ID=wx1234567890
WECHAT_MCH_ID=1234567890
WECHAT_PUBLIC_KEY_PATH=./certs/wechat_public_key.pem
WECHAT_PRIVATE_KEY_PATH=./certs/wechat_private_key.pem
WECHAT_API_V3_KEY=your_api_v3_key

# Stripeé…ç½®
STRIPE_SECRET_KEY=sk_test_...
STRIPE_PUBLISHABLE_KEY=pk_test_...
STRIPE_WEBHOOK_SECRET=whsec_...

# å‰ç«¯URL
FRONTEND_URL=https://yourdomain.com
```

### å¯åŠ¨å®šæ—¶ä»»åŠ¡

```javascript
// src/app.js

const { startOrderExpirationJob } = require('./jobs/orderExpiration');

// å¯åŠ¨è®¢å•è¿‡æœŸå®šæ—¶ä»»åŠ¡
startOrderExpirationJob();
```

---

## ğŸ“ æ€»ç»“

è®¢å•æ”¯ä»˜ç³»ç»Ÿæ˜¯å•†ä¸šåŒ–å¹³å°çš„æ ¸å¿ƒï¼Œæœ¬æ–‡æ¡£æä¾›äº†ï¼š

âœ… å®Œæ•´çš„æ•°æ®åº“è®¾è®¡
âœ… ä¸‰ç§ä¸»æµæ”¯ä»˜æ–¹å¼é›†æˆï¼ˆæ”¯ä»˜å®ã€å¾®ä¿¡ã€Stripeï¼‰
âœ… å®‰å…¨çš„æ”¯ä»˜å›è°ƒå¤„ç†
âœ… è®¢å•ç”Ÿå‘½å‘¨æœŸç®¡ç†
âœ… è‡ªåŠ¨è¿‡æœŸå¤„ç†
âœ… å®Œæ•´çš„ä»£ç å®ç°

### ä¸‹ä¸€ä¸ªåŠŸèƒ½

è®¢å•æ”¯ä»˜ç³»ç»Ÿå®Œæˆåï¼Œä¸‹ä¸€æ­¥æ˜¯ï¼š**è®¢é˜…ç®¡ç†ç³»ç»Ÿ** - ç®¡ç†ç”¨æˆ·çš„è®¢é˜…çŠ¶æ€ã€ç»­è´¹ã€å‡çº§ç­‰ã€‚

---

**æ–‡æ¡£ç‰ˆæœ¬ï¼š** v1.0  
**æœ€åæ›´æ–°ï¼š** 2024-12-26  
**ä½œè€…ï¼š** Claude
